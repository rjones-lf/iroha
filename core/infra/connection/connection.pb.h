// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connection.proto

#ifndef PROTOBUF_connection_2eproto__INCLUDED
#define PROTOBUF_connection_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)

namespace connection {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_connection_2eproto();
void protobuf_AssignDesc_connection_2eproto();
void protobuf_ShutdownFile_connection_2eproto();

class Asset;
class ConsensusEvent;
class Domain;
class EventSignature;
class StatusResponse;
class Transaction;
class TxSignatures;

// ===================================================================

class Asset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection.Asset) */ {
 public:
  Asset();
  virtual ~Asset();

  Asset(const Asset& from);

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Asset& default_instance();

  void Swap(Asset* other);

  // implements Message ----------------------------------------------

  inline Asset* New() const { return New(NULL); }

  Asset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Asset& from);
  void MergeFrom(const Asset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Asset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  void clear_domain();
  static const int kDomainFieldNumber = 1;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint64 value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // optional uint64 precision = 4;
  void clear_precision();
  static const int kPrecisionFieldNumber = 4;
  ::google::protobuf::uint64 precision() const;
  void set_precision(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:connection.Asset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 value_;
  ::google::protobuf::uint64 precision_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static Asset* default_instance_;
};
// -------------------------------------------------------------------

class Domain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection.Domain) */ {
 public:
  Domain();
  virtual ~Domain();

  Domain(const Domain& from);

  inline Domain& operator=(const Domain& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Domain& default_instance();

  void Swap(Domain* other);

  // implements Message ----------------------------------------------

  inline Domain* New() const { return New(NULL); }

  Domain* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Domain& from);
  void MergeFrom(const Domain& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Domain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ownerPublicKey = 1;
  void clear_ownerpublickey();
  static const int kOwnerPublicKeyFieldNumber = 1;
  const ::std::string& ownerpublickey() const;
  void set_ownerpublickey(const ::std::string& value);
  void set_ownerpublickey(const char* value);
  void set_ownerpublickey(const char* value, size_t size);
  ::std::string* mutable_ownerpublickey();
  ::std::string* release_ownerpublickey();
  void set_allocated_ownerpublickey(::std::string* ownerpublickey);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:connection.Domain)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr ownerpublickey_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static Domain* default_instance_;
};
// -------------------------------------------------------------------

class TxSignatures : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection.TxSignatures) */ {
 public:
  TxSignatures();
  virtual ~TxSignatures();

  TxSignatures(const TxSignatures& from);

  inline TxSignatures& operator=(const TxSignatures& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxSignatures& default_instance();

  void Swap(TxSignatures* other);

  // implements Message ----------------------------------------------

  inline TxSignatures* New() const { return New(NULL); }

  TxSignatures* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxSignatures& from);
  void MergeFrom(const TxSignatures& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxSignatures* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string publicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional string signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:connection.TxSignatures)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static TxSignatures* default_instance_;
};
// -------------------------------------------------------------------

class EventSignature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection.EventSignature) */ {
 public:
  EventSignature();
  virtual ~EventSignature();

  EventSignature(const EventSignature& from);

  inline EventSignature& operator=(const EventSignature& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventSignature& default_instance();

  void Swap(EventSignature* other);

  // implements Message ----------------------------------------------

  inline EventSignature* New() const { return New(NULL); }

  EventSignature* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventSignature& from);
  void MergeFrom(const EventSignature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string publicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional string signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:connection.EventSignature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static EventSignature* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  void Swap(Transaction* other);

  // implements Message ----------------------------------------------

  inline Transaction* New() const { return New(NULL); }

  Transaction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .connection.TxSignatures txSignatures = 1;
  int txsignatures_size() const;
  void clear_txsignatures();
  static const int kTxSignaturesFieldNumber = 1;
  const ::connection::TxSignatures& txsignatures(int index) const;
  ::connection::TxSignatures* mutable_txsignatures(int index);
  ::connection::TxSignatures* add_txsignatures();
  ::google::protobuf::RepeatedPtrField< ::connection::TxSignatures >*
      mutable_txsignatures();
  const ::google::protobuf::RepeatedPtrField< ::connection::TxSignatures >&
      txsignatures() const;

  // optional string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional .google.protobuf.Any objects = 3;
  bool has_objects() const;
  void clear_objects();
  static const int kObjectsFieldNumber = 3;
  const ::google::protobuf::Any& objects() const;
  ::google::protobuf::Any* mutable_objects();
  ::google::protobuf::Any* release_objects();
  void set_allocated_objects(::google::protobuf::Any* objects);

  // optional string senderPubkey = 4;
  void clear_senderpubkey();
  static const int kSenderPubkeyFieldNumber = 4;
  const ::std::string& senderpubkey() const;
  void set_senderpubkey(const ::std::string& value);
  void set_senderpubkey(const char* value);
  void set_senderpubkey(const char* value, size_t size);
  ::std::string* mutable_senderpubkey();
  ::std::string* release_senderpubkey();
  void set_allocated_senderpubkey(::std::string* senderpubkey);

  // optional string hash = 5;
  void clear_hash();
  static const int kHashFieldNumber = 5;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional string value = 6;
  void clear_value();
  static const int kValueFieldNumber = 6;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:connection.Transaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::connection::TxSignatures > txsignatures_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::Any* objects_;
  ::google::protobuf::internal::ArenaStringPtr senderpubkey_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class ConsensusEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection.ConsensusEvent) */ {
 public:
  ConsensusEvent();
  virtual ~ConsensusEvent();

  ConsensusEvent(const ConsensusEvent& from);

  inline ConsensusEvent& operator=(const ConsensusEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsensusEvent& default_instance();

  void Swap(ConsensusEvent* other);

  // implements Message ----------------------------------------------

  inline ConsensusEvent* New() const { return New(NULL); }

  ConsensusEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConsensusEvent& from);
  void MergeFrom(const ConsensusEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConsensusEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .connection.EventSignature eventSignatures = 1;
  int eventsignatures_size() const;
  void clear_eventsignatures();
  static const int kEventSignaturesFieldNumber = 1;
  const ::connection::EventSignature& eventsignatures(int index) const;
  ::connection::EventSignature* mutable_eventsignatures(int index);
  ::connection::EventSignature* add_eventsignatures();
  ::google::protobuf::RepeatedPtrField< ::connection::EventSignature >*
      mutable_eventsignatures();
  const ::google::protobuf::RepeatedPtrField< ::connection::EventSignature >&
      eventsignatures() const;

  // optional .connection.Transaction transaction = 2;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 2;
  const ::connection::Transaction& transaction() const;
  ::connection::Transaction* mutable_transaction();
  ::connection::Transaction* release_transaction();
  void set_allocated_transaction(::connection::Transaction* transaction);

  // @@protoc_insertion_point(class_scope:connection.ConsensusEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::connection::EventSignature > eventsignatures_;
  ::connection::Transaction* transaction_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static ConsensusEvent* default_instance_;
};
// -------------------------------------------------------------------

class StatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection.StatusResponse) */ {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusResponse& default_instance();

  void Swap(StatusResponse* other);

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const { return New(NULL); }

  StatusResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:connection.StatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static StatusResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Asset

// optional string domain = 1;
inline void Asset::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Asset::domain() const {
  // @@protoc_insertion_point(field_get:connection.Asset.domain)
  return domain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.Asset.domain)
}
inline void Asset::set_domain(const char* value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.Asset.domain)
}
inline void Asset::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.Asset.domain)
}
inline ::std::string* Asset::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:connection.Asset.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Asset::release_domain() {
  // @@protoc_insertion_point(field_release:connection.Asset.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_domain(::std::string* domain) {
  if (domain != NULL) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:connection.Asset.domain)
}

// optional string name = 2;
inline void Asset::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Asset::name() const {
  // @@protoc_insertion_point(field_get:connection.Asset.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.Asset.name)
}
inline void Asset::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.Asset.name)
}
inline void Asset::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.Asset.name)
}
inline ::std::string* Asset::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:connection.Asset.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Asset::release_name() {
  // @@protoc_insertion_point(field_release:connection.Asset.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:connection.Asset.name)
}

// optional uint64 value = 3;
inline void Asset::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Asset::value() const {
  // @@protoc_insertion_point(field_get:connection.Asset.value)
  return value_;
}
inline void Asset::set_value(::google::protobuf::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:connection.Asset.value)
}

// optional uint64 precision = 4;
inline void Asset::clear_precision() {
  precision_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Asset::precision() const {
  // @@protoc_insertion_point(field_get:connection.Asset.precision)
  return precision_;
}
inline void Asset::set_precision(::google::protobuf::uint64 value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:connection.Asset.precision)
}

// -------------------------------------------------------------------

// Domain

// optional string ownerPublicKey = 1;
inline void Domain::clear_ownerpublickey() {
  ownerpublickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Domain::ownerpublickey() const {
  // @@protoc_insertion_point(field_get:connection.Domain.ownerPublicKey)
  return ownerpublickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_ownerpublickey(const ::std::string& value) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.Domain.ownerPublicKey)
}
inline void Domain::set_ownerpublickey(const char* value) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.Domain.ownerPublicKey)
}
inline void Domain::set_ownerpublickey(const char* value, size_t size) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.Domain.ownerPublicKey)
}
inline ::std::string* Domain::mutable_ownerpublickey() {
  
  // @@protoc_insertion_point(field_mutable:connection.Domain.ownerPublicKey)
  return ownerpublickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Domain::release_ownerpublickey() {
  // @@protoc_insertion_point(field_release:connection.Domain.ownerPublicKey)
  
  return ownerpublickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_allocated_ownerpublickey(::std::string* ownerpublickey) {
  if (ownerpublickey != NULL) {
    
  } else {
    
  }
  ownerpublickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ownerpublickey);
  // @@protoc_insertion_point(field_set_allocated:connection.Domain.ownerPublicKey)
}

// optional string name = 2;
inline void Domain::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Domain::name() const {
  // @@protoc_insertion_point(field_get:connection.Domain.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.Domain.name)
}
inline void Domain::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.Domain.name)
}
inline void Domain::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.Domain.name)
}
inline ::std::string* Domain::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:connection.Domain.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Domain::release_name() {
  // @@protoc_insertion_point(field_release:connection.Domain.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:connection.Domain.name)
}

// -------------------------------------------------------------------

// TxSignatures

// optional string publicKey = 1;
inline void TxSignatures::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxSignatures::publickey() const {
  // @@protoc_insertion_point(field_get:connection.TxSignatures.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.TxSignatures.publicKey)
}
inline void TxSignatures::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.TxSignatures.publicKey)
}
inline void TxSignatures::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.TxSignatures.publicKey)
}
inline ::std::string* TxSignatures::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:connection.TxSignatures.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxSignatures::release_publickey() {
  // @@protoc_insertion_point(field_release:connection.TxSignatures.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:connection.TxSignatures.publicKey)
}

// optional string signature = 2;
inline void TxSignatures::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxSignatures::signature() const {
  // @@protoc_insertion_point(field_get:connection.TxSignatures.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.TxSignatures.signature)
}
inline void TxSignatures::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.TxSignatures.signature)
}
inline void TxSignatures::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.TxSignatures.signature)
}
inline ::std::string* TxSignatures::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:connection.TxSignatures.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxSignatures::release_signature() {
  // @@protoc_insertion_point(field_release:connection.TxSignatures.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:connection.TxSignatures.signature)
}

// -------------------------------------------------------------------

// EventSignature

// optional string publicKey = 1;
inline void EventSignature::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventSignature::publickey() const {
  // @@protoc_insertion_point(field_get:connection.EventSignature.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.EventSignature.publicKey)
}
inline void EventSignature::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.EventSignature.publicKey)
}
inline void EventSignature::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.EventSignature.publicKey)
}
inline ::std::string* EventSignature::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:connection.EventSignature.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventSignature::release_publickey() {
  // @@protoc_insertion_point(field_release:connection.EventSignature.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:connection.EventSignature.publicKey)
}

// optional string signature = 2;
inline void EventSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventSignature::signature() const {
  // @@protoc_insertion_point(field_get:connection.EventSignature.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.EventSignature.signature)
}
inline void EventSignature::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.EventSignature.signature)
}
inline void EventSignature::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.EventSignature.signature)
}
inline ::std::string* EventSignature::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:connection.EventSignature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventSignature::release_signature() {
  // @@protoc_insertion_point(field_release:connection.EventSignature.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:connection.EventSignature.signature)
}

// -------------------------------------------------------------------

// Transaction

// repeated .connection.TxSignatures txSignatures = 1;
inline int Transaction::txsignatures_size() const {
  return txsignatures_.size();
}
inline void Transaction::clear_txsignatures() {
  txsignatures_.Clear();
}
inline const ::connection::TxSignatures& Transaction::txsignatures(int index) const {
  // @@protoc_insertion_point(field_get:connection.Transaction.txSignatures)
  return txsignatures_.Get(index);
}
inline ::connection::TxSignatures* Transaction::mutable_txsignatures(int index) {
  // @@protoc_insertion_point(field_mutable:connection.Transaction.txSignatures)
  return txsignatures_.Mutable(index);
}
inline ::connection::TxSignatures* Transaction::add_txsignatures() {
  // @@protoc_insertion_point(field_add:connection.Transaction.txSignatures)
  return txsignatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::connection::TxSignatures >*
Transaction::mutable_txsignatures() {
  // @@protoc_insertion_point(field_mutable_list:connection.Transaction.txSignatures)
  return &txsignatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::connection::TxSignatures >&
Transaction::txsignatures() const {
  // @@protoc_insertion_point(field_list:connection.Transaction.txSignatures)
  return txsignatures_;
}

// optional string type = 2;
inline void Transaction::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::type() const {
  // @@protoc_insertion_point(field_get:connection.Transaction.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.Transaction.type)
}
inline void Transaction::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.Transaction.type)
}
inline void Transaction::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.Transaction.type)
}
inline ::std::string* Transaction::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:connection.Transaction.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_type() {
  // @@protoc_insertion_point(field_release:connection.Transaction.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:connection.Transaction.type)
}

// optional .google.protobuf.Any objects = 3;
inline bool Transaction::has_objects() const {
  return !_is_default_instance_ && objects_ != NULL;
}
inline void Transaction::clear_objects() {
  if (GetArenaNoVirtual() == NULL && objects_ != NULL) delete objects_;
  objects_ = NULL;
}
inline const ::google::protobuf::Any& Transaction::objects() const {
  // @@protoc_insertion_point(field_get:connection.Transaction.objects)
  return objects_ != NULL ? *objects_ : *default_instance_->objects_;
}
inline ::google::protobuf::Any* Transaction::mutable_objects() {
  
  if (objects_ == NULL) {
    objects_ = new ::google::protobuf::Any;
  }
  // @@protoc_insertion_point(field_mutable:connection.Transaction.objects)
  return objects_;
}
inline ::google::protobuf::Any* Transaction::release_objects() {
  // @@protoc_insertion_point(field_release:connection.Transaction.objects)
  
  ::google::protobuf::Any* temp = objects_;
  objects_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_objects(::google::protobuf::Any* objects) {
  delete objects_;
  objects_ = objects;
  if (objects) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:connection.Transaction.objects)
}

// optional string senderPubkey = 4;
inline void Transaction::clear_senderpubkey() {
  senderpubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::senderpubkey() const {
  // @@protoc_insertion_point(field_get:connection.Transaction.senderPubkey)
  return senderpubkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_senderpubkey(const ::std::string& value) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.Transaction.senderPubkey)
}
inline void Transaction::set_senderpubkey(const char* value) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.Transaction.senderPubkey)
}
inline void Transaction::set_senderpubkey(const char* value, size_t size) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.Transaction.senderPubkey)
}
inline ::std::string* Transaction::mutable_senderpubkey() {
  
  // @@protoc_insertion_point(field_mutable:connection.Transaction.senderPubkey)
  return senderpubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_senderpubkey() {
  // @@protoc_insertion_point(field_release:connection.Transaction.senderPubkey)
  
  return senderpubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_senderpubkey(::std::string* senderpubkey) {
  if (senderpubkey != NULL) {
    
  } else {
    
  }
  senderpubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), senderpubkey);
  // @@protoc_insertion_point(field_set_allocated:connection.Transaction.senderPubkey)
}

// optional string hash = 5;
inline void Transaction::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::hash() const {
  // @@protoc_insertion_point(field_get:connection.Transaction.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.Transaction.hash)
}
inline void Transaction::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.Transaction.hash)
}
inline void Transaction::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.Transaction.hash)
}
inline ::std::string* Transaction::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:connection.Transaction.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_hash() {
  // @@protoc_insertion_point(field_release:connection.Transaction.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:connection.Transaction.hash)
}

// optional string value = 6;
inline void Transaction::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::value() const {
  // @@protoc_insertion_point(field_get:connection.Transaction.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.Transaction.value)
}
inline void Transaction::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.Transaction.value)
}
inline void Transaction::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.Transaction.value)
}
inline ::std::string* Transaction::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:connection.Transaction.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_value() {
  // @@protoc_insertion_point(field_release:connection.Transaction.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:connection.Transaction.value)
}

// -------------------------------------------------------------------

// ConsensusEvent

// repeated .connection.EventSignature eventSignatures = 1;
inline int ConsensusEvent::eventsignatures_size() const {
  return eventsignatures_.size();
}
inline void ConsensusEvent::clear_eventsignatures() {
  eventsignatures_.Clear();
}
inline const ::connection::EventSignature& ConsensusEvent::eventsignatures(int index) const {
  // @@protoc_insertion_point(field_get:connection.ConsensusEvent.eventSignatures)
  return eventsignatures_.Get(index);
}
inline ::connection::EventSignature* ConsensusEvent::mutable_eventsignatures(int index) {
  // @@protoc_insertion_point(field_mutable:connection.ConsensusEvent.eventSignatures)
  return eventsignatures_.Mutable(index);
}
inline ::connection::EventSignature* ConsensusEvent::add_eventsignatures() {
  // @@protoc_insertion_point(field_add:connection.ConsensusEvent.eventSignatures)
  return eventsignatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::connection::EventSignature >*
ConsensusEvent::mutable_eventsignatures() {
  // @@protoc_insertion_point(field_mutable_list:connection.ConsensusEvent.eventSignatures)
  return &eventsignatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::connection::EventSignature >&
ConsensusEvent::eventsignatures() const {
  // @@protoc_insertion_point(field_list:connection.ConsensusEvent.eventSignatures)
  return eventsignatures_;
}

// optional .connection.Transaction transaction = 2;
inline bool ConsensusEvent::has_transaction() const {
  return !_is_default_instance_ && transaction_ != NULL;
}
inline void ConsensusEvent::clear_transaction() {
  if (GetArenaNoVirtual() == NULL && transaction_ != NULL) delete transaction_;
  transaction_ = NULL;
}
inline const ::connection::Transaction& ConsensusEvent::transaction() const {
  // @@protoc_insertion_point(field_get:connection.ConsensusEvent.transaction)
  return transaction_ != NULL ? *transaction_ : *default_instance_->transaction_;
}
inline ::connection::Transaction* ConsensusEvent::mutable_transaction() {
  
  if (transaction_ == NULL) {
    transaction_ = new ::connection::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:connection.ConsensusEvent.transaction)
  return transaction_;
}
inline ::connection::Transaction* ConsensusEvent::release_transaction() {
  // @@protoc_insertion_point(field_release:connection.ConsensusEvent.transaction)
  
  ::connection::Transaction* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline void ConsensusEvent::set_allocated_transaction(::connection::Transaction* transaction) {
  delete transaction_;
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:connection.ConsensusEvent.transaction)
}

// -------------------------------------------------------------------

// StatusResponse

// optional string value = 1;
inline void StatusResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusResponse::value() const {
  // @@protoc_insertion_point(field_get:connection.StatusResponse.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection.StatusResponse.value)
}
inline void StatusResponse::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection.StatusResponse.value)
}
inline void StatusResponse::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection.StatusResponse.value)
}
inline ::std::string* StatusResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:connection.StatusResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusResponse::release_value() {
  // @@protoc_insertion_point(field_release:connection.StatusResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:connection.StatusResponse.value)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace connection

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_connection_2eproto__INCLUDED
