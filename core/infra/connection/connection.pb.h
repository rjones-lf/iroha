// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connection.proto

#ifndef PROTOBUF_connection_2eproto__INCLUDED
#define PROTOBUF_connection_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace connection_object {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_connection_2eproto();
void protobuf_AssignDesc_connection_2eproto();
void protobuf_ShutdownFile_connection_2eproto();

class Asset;
class ConsensusEvent;
class Domain;
class EventSignature;
class StatusResponse;
class Transaction;
class TxSignatures;

// ===================================================================

class Asset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection_object.Asset) */ {
 public:
  Asset();
  virtual ~Asset();

  Asset(const Asset& from);

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Asset& default_instance();

  void Swap(Asset* other);

  // implements Message ----------------------------------------------

  inline Asset* New() const { return New(NULL); }

  Asset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Asset& from);
  void MergeFrom(const Asset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Asset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  void clear_domain();
  static const int kDomainFieldNumber = 1;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint64 value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // optional uint64 precision = 4;
  void clear_precision();
  static const int kPrecisionFieldNumber = 4;
  ::google::protobuf::uint64 precision() const;
  void set_precision(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:connection_object.Asset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 value_;
  ::google::protobuf::uint64 precision_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static Asset* default_instance_;
};
// -------------------------------------------------------------------

class Domain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection_object.Domain) */ {
 public:
  Domain();
  virtual ~Domain();

  Domain(const Domain& from);

  inline Domain& operator=(const Domain& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Domain& default_instance();

  void Swap(Domain* other);

  // implements Message ----------------------------------------------

  inline Domain* New() const { return New(NULL); }

  Domain* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Domain& from);
  void MergeFrom(const Domain& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Domain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ownerPublicKey = 1;
  void clear_ownerpublickey();
  static const int kOwnerPublicKeyFieldNumber = 1;
  const ::std::string& ownerpublickey() const;
  void set_ownerpublickey(const ::std::string& value);
  void set_ownerpublickey(const char* value);
  void set_ownerpublickey(const char* value, size_t size);
  ::std::string* mutable_ownerpublickey();
  ::std::string* release_ownerpublickey();
  void set_allocated_ownerpublickey(::std::string* ownerpublickey);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:connection_object.Domain)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr ownerpublickey_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static Domain* default_instance_;
};
// -------------------------------------------------------------------

class TxSignatures : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection_object.TxSignatures) */ {
 public:
  TxSignatures();
  virtual ~TxSignatures();

  TxSignatures(const TxSignatures& from);

  inline TxSignatures& operator=(const TxSignatures& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxSignatures& default_instance();

  void Swap(TxSignatures* other);

  // implements Message ----------------------------------------------

  inline TxSignatures* New() const { return New(NULL); }

  TxSignatures* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxSignatures& from);
  void MergeFrom(const TxSignatures& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxSignatures* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string publicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional string signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:connection_object.TxSignatures)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static TxSignatures* default_instance_;
};
// -------------------------------------------------------------------

class EventSignature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection_object.EventSignature) */ {
 public:
  EventSignature();
  virtual ~EventSignature();

  EventSignature(const EventSignature& from);

  inline EventSignature& operator=(const EventSignature& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventSignature& default_instance();

  void Swap(EventSignature* other);

  // implements Message ----------------------------------------------

  inline EventSignature* New() const { return New(NULL); }

  EventSignature* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventSignature& from);
  void MergeFrom(const EventSignature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string publicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional string signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:connection_object.EventSignature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static EventSignature* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection_object.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  void Swap(Transaction* other);

  // implements Message ----------------------------------------------

  inline Transaction* New() const { return New(NULL); }

  Transaction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .connection_object.TxSignatures txSignatures = 1;
  int txsignatures_size() const;
  void clear_txsignatures();
  static const int kTxSignaturesFieldNumber = 1;
  const ::connection_object::TxSignatures& txsignatures(int index) const;
  ::connection_object::TxSignatures* mutable_txsignatures(int index);
  ::connection_object::TxSignatures* add_txsignatures();
  ::google::protobuf::RepeatedPtrField< ::connection_object::TxSignatures >*
      mutable_txsignatures();
  const ::google::protobuf::RepeatedPtrField< ::connection_object::TxSignatures >&
      txsignatures() const;

  // optional string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string senderPubkey = 4;
  void clear_senderpubkey();
  static const int kSenderPubkeyFieldNumber = 4;
  const ::std::string& senderpubkey() const;
  void set_senderpubkey(const ::std::string& value);
  void set_senderpubkey(const char* value);
  void set_senderpubkey(const char* value, size_t size);
  ::std::string* mutable_senderpubkey();
  ::std::string* release_senderpubkey();
  void set_allocated_senderpubkey(::std::string* senderpubkey);

  // optional string hash = 5;
  void clear_hash();
  static const int kHashFieldNumber = 5;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional .connection_object.Asset asset = 6;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 6;
  const ::connection_object::Asset& asset() const;
  ::connection_object::Asset* mutable_asset();
  ::connection_object::Asset* release_asset();
  void set_allocated_asset(::connection_object::Asset* asset);

  // optional .connection_object.Domain domain = 7;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 7;
  const ::connection_object::Domain& domain() const;
  ::connection_object::Domain* mutable_domain();
  ::connection_object::Domain* release_domain();
  void set_allocated_domain(::connection_object::Domain* domain);

  // optional string receivePubkey = 8;
  void clear_receivepubkey();
  static const int kReceivePubkeyFieldNumber = 8;
  const ::std::string& receivepubkey() const;
  void set_receivepubkey(const ::std::string& value);
  void set_receivepubkey(const char* value);
  void set_receivepubkey(const char* value, size_t size);
  ::std::string* mutable_receivepubkey();
  ::std::string* release_receivepubkey();
  void set_allocated_receivepubkey(::std::string* receivepubkey);

  // @@protoc_insertion_point(class_scope:connection_object.Transaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::connection_object::TxSignatures > txsignatures_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr senderpubkey_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::connection_object::Asset* asset_;
  ::connection_object::Domain* domain_;
  ::google::protobuf::internal::ArenaStringPtr receivepubkey_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class ConsensusEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection_object.ConsensusEvent) */ {
 public:
  ConsensusEvent();
  virtual ~ConsensusEvent();

  ConsensusEvent(const ConsensusEvent& from);

  inline ConsensusEvent& operator=(const ConsensusEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsensusEvent& default_instance();

  void Swap(ConsensusEvent* other);

  // implements Message ----------------------------------------------

  inline ConsensusEvent* New() const { return New(NULL); }

  ConsensusEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConsensusEvent& from);
  void MergeFrom(const ConsensusEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConsensusEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .connection_object.EventSignature eventSignatures = 1;
  int eventsignatures_size() const;
  void clear_eventsignatures();
  static const int kEventSignaturesFieldNumber = 1;
  const ::connection_object::EventSignature& eventsignatures(int index) const;
  ::connection_object::EventSignature* mutable_eventsignatures(int index);
  ::connection_object::EventSignature* add_eventsignatures();
  ::google::protobuf::RepeatedPtrField< ::connection_object::EventSignature >*
      mutable_eventsignatures();
  const ::google::protobuf::RepeatedPtrField< ::connection_object::EventSignature >&
      eventsignatures() const;

  // optional .connection_object.Transaction transaction = 2;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 2;
  const ::connection_object::Transaction& transaction() const;
  ::connection_object::Transaction* mutable_transaction();
  ::connection_object::Transaction* release_transaction();
  void set_allocated_transaction(::connection_object::Transaction* transaction);

  // @@protoc_insertion_point(class_scope:connection_object.ConsensusEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::connection_object::EventSignature > eventsignatures_;
  ::connection_object::Transaction* transaction_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static ConsensusEvent* default_instance_;
};
// -------------------------------------------------------------------

class StatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:connection_object.StatusResponse) */ {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusResponse& default_instance();

  void Swap(StatusResponse* other);

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const { return New(NULL); }

  StatusResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:connection_object.StatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_connection_2eproto();
  friend void protobuf_AssignDesc_connection_2eproto();
  friend void protobuf_ShutdownFile_connection_2eproto();

  void InitAsDefaultInstance();
  static StatusResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Asset

// optional string domain = 1;
inline void Asset::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Asset::domain() const {
  // @@protoc_insertion_point(field_get:connection_object.Asset.domain)
  return domain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.Asset.domain)
}
inline void Asset::set_domain(const char* value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.Asset.domain)
}
inline void Asset::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.Asset.domain)
}
inline ::std::string* Asset::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.Asset.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Asset::release_domain() {
  // @@protoc_insertion_point(field_release:connection_object.Asset.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_domain(::std::string* domain) {
  if (domain != NULL) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:connection_object.Asset.domain)
}

// optional string name = 2;
inline void Asset::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Asset::name() const {
  // @@protoc_insertion_point(field_get:connection_object.Asset.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.Asset.name)
}
inline void Asset::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.Asset.name)
}
inline void Asset::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.Asset.name)
}
inline ::std::string* Asset::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.Asset.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Asset::release_name() {
  // @@protoc_insertion_point(field_release:connection_object.Asset.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:connection_object.Asset.name)
}

// optional uint64 value = 3;
inline void Asset::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Asset::value() const {
  // @@protoc_insertion_point(field_get:connection_object.Asset.value)
  return value_;
}
inline void Asset::set_value(::google::protobuf::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:connection_object.Asset.value)
}

// optional uint64 precision = 4;
inline void Asset::clear_precision() {
  precision_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Asset::precision() const {
  // @@protoc_insertion_point(field_get:connection_object.Asset.precision)
  return precision_;
}
inline void Asset::set_precision(::google::protobuf::uint64 value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:connection_object.Asset.precision)
}

// -------------------------------------------------------------------

// Domain

// optional string ownerPublicKey = 1;
inline void Domain::clear_ownerpublickey() {
  ownerpublickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Domain::ownerpublickey() const {
  // @@protoc_insertion_point(field_get:connection_object.Domain.ownerPublicKey)
  return ownerpublickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_ownerpublickey(const ::std::string& value) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.Domain.ownerPublicKey)
}
inline void Domain::set_ownerpublickey(const char* value) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.Domain.ownerPublicKey)
}
inline void Domain::set_ownerpublickey(const char* value, size_t size) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.Domain.ownerPublicKey)
}
inline ::std::string* Domain::mutable_ownerpublickey() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.Domain.ownerPublicKey)
  return ownerpublickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Domain::release_ownerpublickey() {
  // @@protoc_insertion_point(field_release:connection_object.Domain.ownerPublicKey)
  
  return ownerpublickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_allocated_ownerpublickey(::std::string* ownerpublickey) {
  if (ownerpublickey != NULL) {
    
  } else {
    
  }
  ownerpublickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ownerpublickey);
  // @@protoc_insertion_point(field_set_allocated:connection_object.Domain.ownerPublicKey)
}

// optional string name = 2;
inline void Domain::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Domain::name() const {
  // @@protoc_insertion_point(field_get:connection_object.Domain.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.Domain.name)
}
inline void Domain::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.Domain.name)
}
inline void Domain::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.Domain.name)
}
inline ::std::string* Domain::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.Domain.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Domain::release_name() {
  // @@protoc_insertion_point(field_release:connection_object.Domain.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:connection_object.Domain.name)
}

// -------------------------------------------------------------------

// TxSignatures

// optional string publicKey = 1;
inline void TxSignatures::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxSignatures::publickey() const {
  // @@protoc_insertion_point(field_get:connection_object.TxSignatures.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.TxSignatures.publicKey)
}
inline void TxSignatures::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.TxSignatures.publicKey)
}
inline void TxSignatures::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.TxSignatures.publicKey)
}
inline ::std::string* TxSignatures::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.TxSignatures.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxSignatures::release_publickey() {
  // @@protoc_insertion_point(field_release:connection_object.TxSignatures.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:connection_object.TxSignatures.publicKey)
}

// optional string signature = 2;
inline void TxSignatures::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxSignatures::signature() const {
  // @@protoc_insertion_point(field_get:connection_object.TxSignatures.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.TxSignatures.signature)
}
inline void TxSignatures::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.TxSignatures.signature)
}
inline void TxSignatures::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.TxSignatures.signature)
}
inline ::std::string* TxSignatures::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.TxSignatures.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxSignatures::release_signature() {
  // @@protoc_insertion_point(field_release:connection_object.TxSignatures.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:connection_object.TxSignatures.signature)
}

// -------------------------------------------------------------------

// EventSignature

// optional string publicKey = 1;
inline void EventSignature::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventSignature::publickey() const {
  // @@protoc_insertion_point(field_get:connection_object.EventSignature.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.EventSignature.publicKey)
}
inline void EventSignature::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.EventSignature.publicKey)
}
inline void EventSignature::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.EventSignature.publicKey)
}
inline ::std::string* EventSignature::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.EventSignature.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventSignature::release_publickey() {
  // @@protoc_insertion_point(field_release:connection_object.EventSignature.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:connection_object.EventSignature.publicKey)
}

// optional string signature = 2;
inline void EventSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventSignature::signature() const {
  // @@protoc_insertion_point(field_get:connection_object.EventSignature.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.EventSignature.signature)
}
inline void EventSignature::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.EventSignature.signature)
}
inline void EventSignature::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.EventSignature.signature)
}
inline ::std::string* EventSignature::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.EventSignature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventSignature::release_signature() {
  // @@protoc_insertion_point(field_release:connection_object.EventSignature.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:connection_object.EventSignature.signature)
}

// -------------------------------------------------------------------

// Transaction

// repeated .connection_object.TxSignatures txSignatures = 1;
inline int Transaction::txsignatures_size() const {
  return txsignatures_.size();
}
inline void Transaction::clear_txsignatures() {
  txsignatures_.Clear();
}
inline const ::connection_object::TxSignatures& Transaction::txsignatures(int index) const {
  // @@protoc_insertion_point(field_get:connection_object.Transaction.txSignatures)
  return txsignatures_.Get(index);
}
inline ::connection_object::TxSignatures* Transaction::mutable_txsignatures(int index) {
  // @@protoc_insertion_point(field_mutable:connection_object.Transaction.txSignatures)
  return txsignatures_.Mutable(index);
}
inline ::connection_object::TxSignatures* Transaction::add_txsignatures() {
  // @@protoc_insertion_point(field_add:connection_object.Transaction.txSignatures)
  return txsignatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::connection_object::TxSignatures >*
Transaction::mutable_txsignatures() {
  // @@protoc_insertion_point(field_mutable_list:connection_object.Transaction.txSignatures)
  return &txsignatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::connection_object::TxSignatures >&
Transaction::txsignatures() const {
  // @@protoc_insertion_point(field_list:connection_object.Transaction.txSignatures)
  return txsignatures_;
}

// optional string type = 2;
inline void Transaction::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::type() const {
  // @@protoc_insertion_point(field_get:connection_object.Transaction.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.Transaction.type)
}
inline void Transaction::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.Transaction.type)
}
inline void Transaction::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.Transaction.type)
}
inline ::std::string* Transaction::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.Transaction.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_type() {
  // @@protoc_insertion_point(field_release:connection_object.Transaction.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:connection_object.Transaction.type)
}

// optional string senderPubkey = 4;
inline void Transaction::clear_senderpubkey() {
  senderpubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::senderpubkey() const {
  // @@protoc_insertion_point(field_get:connection_object.Transaction.senderPubkey)
  return senderpubkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_senderpubkey(const ::std::string& value) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.Transaction.senderPubkey)
}
inline void Transaction::set_senderpubkey(const char* value) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.Transaction.senderPubkey)
}
inline void Transaction::set_senderpubkey(const char* value, size_t size) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.Transaction.senderPubkey)
}
inline ::std::string* Transaction::mutable_senderpubkey() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.Transaction.senderPubkey)
  return senderpubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_senderpubkey() {
  // @@protoc_insertion_point(field_release:connection_object.Transaction.senderPubkey)
  
  return senderpubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_senderpubkey(::std::string* senderpubkey) {
  if (senderpubkey != NULL) {
    
  } else {
    
  }
  senderpubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), senderpubkey);
  // @@protoc_insertion_point(field_set_allocated:connection_object.Transaction.senderPubkey)
}

// optional string hash = 5;
inline void Transaction::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::hash() const {
  // @@protoc_insertion_point(field_get:connection_object.Transaction.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.Transaction.hash)
}
inline void Transaction::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.Transaction.hash)
}
inline void Transaction::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.Transaction.hash)
}
inline ::std::string* Transaction::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.Transaction.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_hash() {
  // @@protoc_insertion_point(field_release:connection_object.Transaction.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:connection_object.Transaction.hash)
}

// optional .connection_object.Asset asset = 6;
inline bool Transaction::has_asset() const {
  return !_is_default_instance_ && asset_ != NULL;
}
inline void Transaction::clear_asset() {
  if (GetArenaNoVirtual() == NULL && asset_ != NULL) delete asset_;
  asset_ = NULL;
}
inline const ::connection_object::Asset& Transaction::asset() const {
  // @@protoc_insertion_point(field_get:connection_object.Transaction.asset)
  return asset_ != NULL ? *asset_ : *default_instance_->asset_;
}
inline ::connection_object::Asset* Transaction::mutable_asset() {
  
  if (asset_ == NULL) {
    asset_ = new ::connection_object::Asset;
  }
  // @@protoc_insertion_point(field_mutable:connection_object.Transaction.asset)
  return asset_;
}
inline ::connection_object::Asset* Transaction::release_asset() {
  // @@protoc_insertion_point(field_release:connection_object.Transaction.asset)
  
  ::connection_object::Asset* temp = asset_;
  asset_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_asset(::connection_object::Asset* asset) {
  delete asset_;
  asset_ = asset;
  if (asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:connection_object.Transaction.asset)
}

// optional .connection_object.Domain domain = 7;
inline bool Transaction::has_domain() const {
  return !_is_default_instance_ && domain_ != NULL;
}
inline void Transaction::clear_domain() {
  if (GetArenaNoVirtual() == NULL && domain_ != NULL) delete domain_;
  domain_ = NULL;
}
inline const ::connection_object::Domain& Transaction::domain() const {
  // @@protoc_insertion_point(field_get:connection_object.Transaction.domain)
  return domain_ != NULL ? *domain_ : *default_instance_->domain_;
}
inline ::connection_object::Domain* Transaction::mutable_domain() {
  
  if (domain_ == NULL) {
    domain_ = new ::connection_object::Domain;
  }
  // @@protoc_insertion_point(field_mutable:connection_object.Transaction.domain)
  return domain_;
}
inline ::connection_object::Domain* Transaction::release_domain() {
  // @@protoc_insertion_point(field_release:connection_object.Transaction.domain)
  
  ::connection_object::Domain* temp = domain_;
  domain_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_domain(::connection_object::Domain* domain) {
  delete domain_;
  domain_ = domain;
  if (domain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:connection_object.Transaction.domain)
}

// optional string receivePubkey = 8;
inline void Transaction::clear_receivepubkey() {
  receivepubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::receivepubkey() const {
  // @@protoc_insertion_point(field_get:connection_object.Transaction.receivePubkey)
  return receivepubkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_receivepubkey(const ::std::string& value) {
  
  receivepubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.Transaction.receivePubkey)
}
inline void Transaction::set_receivepubkey(const char* value) {
  
  receivepubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.Transaction.receivePubkey)
}
inline void Transaction::set_receivepubkey(const char* value, size_t size) {
  
  receivepubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.Transaction.receivePubkey)
}
inline ::std::string* Transaction::mutable_receivepubkey() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.Transaction.receivePubkey)
  return receivepubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_receivepubkey() {
  // @@protoc_insertion_point(field_release:connection_object.Transaction.receivePubkey)
  
  return receivepubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_receivepubkey(::std::string* receivepubkey) {
  if (receivepubkey != NULL) {
    
  } else {
    
  }
  receivepubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receivepubkey);
  // @@protoc_insertion_point(field_set_allocated:connection_object.Transaction.receivePubkey)
}

// -------------------------------------------------------------------

// ConsensusEvent

// repeated .connection_object.EventSignature eventSignatures = 1;
inline int ConsensusEvent::eventsignatures_size() const {
  return eventsignatures_.size();
}
inline void ConsensusEvent::clear_eventsignatures() {
  eventsignatures_.Clear();
}
inline const ::connection_object::EventSignature& ConsensusEvent::eventsignatures(int index) const {
  // @@protoc_insertion_point(field_get:connection_object.ConsensusEvent.eventSignatures)
  return eventsignatures_.Get(index);
}
inline ::connection_object::EventSignature* ConsensusEvent::mutable_eventsignatures(int index) {
  // @@protoc_insertion_point(field_mutable:connection_object.ConsensusEvent.eventSignatures)
  return eventsignatures_.Mutable(index);
}
inline ::connection_object::EventSignature* ConsensusEvent::add_eventsignatures() {
  // @@protoc_insertion_point(field_add:connection_object.ConsensusEvent.eventSignatures)
  return eventsignatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::connection_object::EventSignature >*
ConsensusEvent::mutable_eventsignatures() {
  // @@protoc_insertion_point(field_mutable_list:connection_object.ConsensusEvent.eventSignatures)
  return &eventsignatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::connection_object::EventSignature >&
ConsensusEvent::eventsignatures() const {
  // @@protoc_insertion_point(field_list:connection_object.ConsensusEvent.eventSignatures)
  return eventsignatures_;
}

// optional .connection_object.Transaction transaction = 2;
inline bool ConsensusEvent::has_transaction() const {
  return !_is_default_instance_ && transaction_ != NULL;
}
inline void ConsensusEvent::clear_transaction() {
  if (GetArenaNoVirtual() == NULL && transaction_ != NULL) delete transaction_;
  transaction_ = NULL;
}
inline const ::connection_object::Transaction& ConsensusEvent::transaction() const {
  // @@protoc_insertion_point(field_get:connection_object.ConsensusEvent.transaction)
  return transaction_ != NULL ? *transaction_ : *default_instance_->transaction_;
}
inline ::connection_object::Transaction* ConsensusEvent::mutable_transaction() {
  
  if (transaction_ == NULL) {
    transaction_ = new ::connection_object::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:connection_object.ConsensusEvent.transaction)
  return transaction_;
}
inline ::connection_object::Transaction* ConsensusEvent::release_transaction() {
  // @@protoc_insertion_point(field_release:connection_object.ConsensusEvent.transaction)
  
  ::connection_object::Transaction* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline void ConsensusEvent::set_allocated_transaction(::connection_object::Transaction* transaction) {
  delete transaction_;
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:connection_object.ConsensusEvent.transaction)
}

// -------------------------------------------------------------------

// StatusResponse

// optional string value = 1;
inline void StatusResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusResponse::value() const {
  // @@protoc_insertion_point(field_get:connection_object.StatusResponse.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:connection_object.StatusResponse.value)
}
inline void StatusResponse::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:connection_object.StatusResponse.value)
}
inline void StatusResponse::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:connection_object.StatusResponse.value)
}
inline ::std::string* StatusResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:connection_object.StatusResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusResponse::release_value() {
  // @@protoc_insertion_point(field_release:connection_object.StatusResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:connection_object.StatusResponse.value)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace connection_object

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_connection_2eproto__INCLUDED
