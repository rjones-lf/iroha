// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_API_IROHA_H_
#define FLATBUFFERS_GENERATED_API_IROHA_H_

#include "flatbuffers/flatbuffers.h"

namespace iroha {

struct BaseObject;

struct Asset;

struct Account;

struct Domain;

struct Peer;

struct Add;

struct Transfer;

struct Update;

struct Remove;

struct Batch;

struct Unbatch;

struct Contract;

struct TxSignature;

struct Transaction;

struct Response;

struct Request;

struct Query;

struct EventSignature;

struct ConsensusEvent;

enum Object {
  Object_NONE = 0,
  Object_Asset = 1,
  Object_Domain = 2,
  Object_Account = 3,
  Object_Peer = 4,
  Object_MIN = Object_NONE,
  Object_MAX = Object_Peer
};

inline const char **EnumNamesObject() {
  static const char *names[] = {
    "NONE",
    "Asset",
    "Domain",
    "Account",
    "Peer",
    nullptr
  };
  return names;
}

inline const char *EnumNameObject(Object e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesObject()[index];
}

template<typename T> struct ObjectTraits {
  static const Object enum_value = Object_NONE;
};

template<> struct ObjectTraits<Asset> {
  static const Object enum_value = Object_Asset;
};

template<> struct ObjectTraits<Domain> {
  static const Object enum_value = Object_Domain;
};

template<> struct ObjectTraits<Account> {
  static const Object enum_value = Object_Account;
};

template<> struct ObjectTraits<Peer> {
  static const Object enum_value = Object_Peer;
};

bool VerifyObject(flatbuffers::Verifier &verifier, const void *obj, Object type);
bool VerifyObjectVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Command {
  Command_NONE = 0,
  Command_Add = 1,
  Command_Transfer = 2,
  Command_Update = 3,
  Command_Remove = 4,
  Command_Batch = 5,
  Command_Unbatch = 6,
  Command_Contract = 7,
  Command_MIN = Command_NONE,
  Command_MAX = Command_Contract
};

inline const char **EnumNamesCommand() {
  static const char *names[] = {
    "NONE",
    "Add",
    "Transfer",
    "Update",
    "Remove",
    "Batch",
    "Unbatch",
    "Contract",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<Add> {
  static const Command enum_value = Command_Add;
};

template<> struct CommandTraits<Transfer> {
  static const Command enum_value = Command_Transfer;
};

template<> struct CommandTraits<Update> {
  static const Command enum_value = Command_Update;
};

template<> struct CommandTraits<Remove> {
  static const Command enum_value = Command_Remove;
};

template<> struct CommandTraits<Batch> {
  static const Command enum_value = Command_Batch;
};

template<> struct CommandTraits<Unbatch> {
  static const Command enum_value = Command_Unbatch;
};

template<> struct CommandTraits<Contract> {
  static const Command enum_value = Command_Contract;
};

bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum QueryType {
  QueryType_TransactionHistory = 0,
  QueryType_HashTree = 1,
  QueryType_ObjectInformation = 2,
  QueryType_MIN = QueryType_TransactionHistory,
  QueryType_MAX = QueryType_ObjectInformation
};

inline const char **EnumNamesQueryType() {
  static const char *names[] = {
    "TransactionHistory",
    "HashTree",
    "ObjectInformation",
    nullptr
  };
  return names;
}

inline const char *EnumNameQueryType(QueryType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesQueryType()[index];
}

enum State {
  State_Undetermined = 0,
  State_Commited = 1,
  State_Rejected = 2,
  State_MIN = State_Undetermined,
  State_MAX = State_Rejected
};

inline const char **EnumNamesState() {
  static const char *names[] = {
    "Undetermined",
    "Commited",
    "Rejected",
    nullptr
  };
  return names;
}

inline const char *EnumNameState(State e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesState()[index];
}

struct BaseObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TEXT = 4,
    VT_INTEGER = 6,
    VT_BOOLEAN = 8,
    VT_DECIMAL = 10,
    VT_NAME = 12
  };
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  int32_t integer() const {
    return GetField<int32_t>(VT_INTEGER, 0);
  }
  bool boolean() const {
    return GetField<uint8_t>(VT_BOOLEAN, 0) != 0;
  }
  float decimal() const {
    return GetField<float>(VT_DECIMAL, 0.0f);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<int32_t>(verifier, VT_INTEGER) &&
           VerifyField<uint8_t>(verifier, VT_BOOLEAN) &&
           VerifyField<float>(verifier, VT_DECIMAL) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct BaseObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(BaseObject::VT_TEXT, text);
  }
  void add_integer(int32_t integer) {
    fbb_.AddElement<int32_t>(BaseObject::VT_INTEGER, integer, 0);
  }
  void add_boolean(bool boolean) {
    fbb_.AddElement<uint8_t>(BaseObject::VT_BOOLEAN, static_cast<uint8_t>(boolean), 0);
  }
  void add_decimal(float decimal) {
    fbb_.AddElement<float>(BaseObject::VT_DECIMAL, decimal, 0.0f);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(BaseObject::VT_NAME, name);
  }
  BaseObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BaseObjectBuilder &operator=(const BaseObjectBuilder &);
  flatbuffers::Offset<BaseObject> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<BaseObject>(end);
    fbb_.Required(o, BaseObject::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<BaseObject> CreateBaseObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    int32_t integer = 0,
    bool boolean = false,
    float decimal = 0.0f,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  BaseObjectBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_decimal(decimal);
  builder_.add_integer(integer);
  builder_.add_text(text);
  builder_.add_boolean(boolean);
  return builder_.Finish();
}

inline flatbuffers::Offset<BaseObject> CreateBaseObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    int32_t integer = 0,
    bool boolean = false,
    float decimal = 0.0f,
    const char *name = nullptr) {
  return CreateBaseObject(
      _fbb,
      text ? _fbb.CreateString(text) : 0,
      integer,
      boolean,
      decimal,
      name ? _fbb.CreateString(name) : 0);
}

struct Asset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DOMAIN = 6,
    VT_ISSINGLEASSET = 8,
    VT_OBJECTS = 10,
    VT_SMARTCONTRACTNAME = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *domain() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN);
  }
  bool isSingleAsset() const {
    return GetField<uint8_t>(VT_ISSINGLEASSET, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<BaseObject>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BaseObject>> *>(VT_OBJECTS);
  }
  const flatbuffers::String *smartContractName() const {
    return GetPointer<const flatbuffers::String *>(VT_SMARTCONTRACTNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN) &&
           verifier.Verify(domain()) &&
           VerifyField<uint8_t>(verifier, VT_ISSINGLEASSET) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OBJECTS) &&
           verifier.Verify(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SMARTCONTRACTNAME) &&
           verifier.Verify(smartContractName()) &&
           verifier.EndTable();
  }
};

struct AssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Asset::VT_NAME, name);
  }
  void add_domain(flatbuffers::Offset<flatbuffers::String> domain) {
    fbb_.AddOffset(Asset::VT_DOMAIN, domain);
  }
  void add_isSingleAsset(bool isSingleAsset) {
    fbb_.AddElement<uint8_t>(Asset::VT_ISSINGLEASSET, static_cast<uint8_t>(isSingleAsset), 0);
  }
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BaseObject>>> objects) {
    fbb_.AddOffset(Asset::VT_OBJECTS, objects);
  }
  void add_smartContractName(flatbuffers::Offset<flatbuffers::String> smartContractName) {
    fbb_.AddOffset(Asset::VT_SMARTCONTRACTNAME, smartContractName);
  }
  AssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetBuilder &operator=(const AssetBuilder &);
  flatbuffers::Offset<Asset> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Asset>(end);
    fbb_.Required(o, Asset::VT_NAME);
    fbb_.Required(o, Asset::VT_DOMAIN);
    return o;
  }
};

inline flatbuffers::Offset<Asset> CreateAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> domain = 0,
    bool isSingleAsset = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BaseObject>>> objects = 0,
    flatbuffers::Offset<flatbuffers::String> smartContractName = 0) {
  AssetBuilder builder_(_fbb);
  builder_.add_smartContractName(smartContractName);
  builder_.add_objects(objects);
  builder_.add_domain(domain);
  builder_.add_name(name);
  builder_.add_isSingleAsset(isSingleAsset);
  return builder_.Finish();
}

inline flatbuffers::Offset<Asset> CreateAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *domain = nullptr,
    bool isSingleAsset = false,
    const std::vector<flatbuffers::Offset<BaseObject>> *objects = nullptr,
    const char *smartContractName = nullptr) {
  return CreateAsset(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      domain ? _fbb.CreateString(domain) : 0,
      isSingleAsset,
      objects ? _fbb.CreateVector<flatbuffers::Offset<BaseObject>>(*objects) : 0,
      smartContractName ? _fbb.CreateString(smartContractName) : 0);
}

struct Account FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEY = 4,
    VT_ASSETS = 6
  };
  const flatbuffers::String *publicKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Asset>> *assets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Asset>> *>(VT_ASSETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ASSETS) &&
           verifier.Verify(assets()) &&
           verifier.VerifyVectorOfTables(assets()) &&
           verifier.EndTable();
  }
};

struct AccountBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) {
    fbb_.AddOffset(Account::VT_PUBLICKEY, publicKey);
  }
  void add_assets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Asset>>> assets) {
    fbb_.AddOffset(Account::VT_ASSETS, assets);
  }
  AccountBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountBuilder &operator=(const AccountBuilder &);
  flatbuffers::Offset<Account> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Account>(end);
    fbb_.Required(o, Account::VT_PUBLICKEY);
    return o;
  }
};

inline flatbuffers::Offset<Account> CreateAccount(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Asset>>> assets = 0) {
  AccountBuilder builder_(_fbb);
  builder_.add_assets(assets);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Account> CreateAccountDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const std::vector<flatbuffers::Offset<Asset>> *assets = nullptr) {
  return CreateAccount(
      _fbb,
      publicKey ? _fbb.CreateString(publicKey) : 0,
      assets ? _fbb.CreateVector<flatbuffers::Offset<Asset>>(*assets) : 0);
}

struct Domain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OWNERPUBLICKEY = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *ownerPublicKey() const {
    return GetPointer<const flatbuffers::String *>(VT_OWNERPUBLICKEY);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OWNERPUBLICKEY) &&
           verifier.Verify(ownerPublicKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct DomainBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ownerPublicKey(flatbuffers::Offset<flatbuffers::String> ownerPublicKey) {
    fbb_.AddOffset(Domain::VT_OWNERPUBLICKEY, ownerPublicKey);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Domain::VT_NAME, name);
  }
  DomainBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DomainBuilder &operator=(const DomainBuilder &);
  flatbuffers::Offset<Domain> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Domain>(end);
    return o;
  }
};

inline flatbuffers::Offset<Domain> CreateDomain(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ownerPublicKey = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  DomainBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_ownerPublicKey(ownerPublicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Domain> CreateDomainDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ownerPublicKey = nullptr,
    const char *name = nullptr) {
  return CreateDomain(
      _fbb,
      ownerPublicKey ? _fbb.CreateString(ownerPublicKey) : 0,
      name ? _fbb.CreateString(name) : 0);
}

struct Peer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEY = 4,
    VT_ADDRESS = 6
  };
  const flatbuffers::String *publicKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           verifier.EndTable();
  }
};

struct PeerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) {
    fbb_.AddOffset(Peer::VT_PUBLICKEY, publicKey);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Peer::VT_ADDRESS, address);
  }
  PeerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerBuilder &operator=(const PeerBuilder &);
  flatbuffers::Offset<Peer> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Peer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Peer> CreatePeer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0) {
  PeerBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Peer> CreatePeerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const char *address = nullptr) {
  return CreatePeer(
      _fbb,
      publicKey ? _fbb.CreateString(publicKey) : 0,
      address ? _fbb.CreateString(address) : 0);
}

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Add::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Add::VT_OBJECT, object);
  }
  AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Add>(end);
    fbb_.Required(o, Add::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  AddBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Transfer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECEIVER = 4,
    VT_OBJECT_TYPE = 6,
    VT_OBJECT = 8
  };
  const flatbuffers::String *receiver() const {
    return GetPointer<const flatbuffers::String *>(VT_RECEIVER);
  }
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_RECEIVER) &&
           verifier.Verify(receiver()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct TransferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_receiver(flatbuffers::Offset<flatbuffers::String> receiver) {
    fbb_.AddOffset(Transfer::VT_RECEIVER, receiver);
  }
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Transfer::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Transfer::VT_OBJECT, object);
  }
  TransferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransferBuilder &operator=(const TransferBuilder &);
  flatbuffers::Offset<Transfer> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Transfer>(end);
    fbb_.Required(o, Transfer::VT_RECEIVER);
    fbb_.Required(o, Transfer::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Transfer> CreateTransfer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> receiver = 0,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  TransferBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_receiver(receiver);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transfer> CreateTransferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *receiver = nullptr,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  return CreateTransfer(
      _fbb,
      receiver ? _fbb.CreateString(receiver) : 0,
      object_type,
      object);
}

struct Update FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct UpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Update::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Update::VT_OBJECT, object);
  }
  UpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateBuilder &operator=(const UpdateBuilder &);
  flatbuffers::Offset<Update> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Update>(end);
    fbb_.Required(o, Update::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Update> CreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  UpdateBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Remove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct RemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Remove::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Remove::VT_OBJECT, object);
  }
  RemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveBuilder &operator=(const RemoveBuilder &);
  flatbuffers::Offset<Remove> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Remove>(end);
    fbb_.Required(o, Remove::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Remove> CreateRemove(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  RemoveBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Batch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALIAS = 4,
    VT_COMMANDS = 6
  };
  const flatbuffers::String *alias() const {
    return GetPointer<const flatbuffers::String *>(VT_ALIAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *commands() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COMMANDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ALIAS) &&
           verifier.Verify(alias()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMANDS) &&
           verifier.Verify(commands()) &&
           verifier.VerifyVectorOfStrings(commands()) &&
           verifier.EndTable();
  }
};

struct BatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alias(flatbuffers::Offset<flatbuffers::String> alias) {
    fbb_.AddOffset(Batch::VT_ALIAS, alias);
  }
  void add_commands(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> commands) {
    fbb_.AddOffset(Batch::VT_COMMANDS, commands);
  }
  BatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchBuilder &operator=(const BatchBuilder &);
  flatbuffers::Offset<Batch> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Batch>(end);
    fbb_.Required(o, Batch::VT_ALIAS);
    return o;
  }
};

inline flatbuffers::Offset<Batch> CreateBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> alias = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> commands = 0) {
  BatchBuilder builder_(_fbb);
  builder_.add_commands(commands);
  builder_.add_alias(alias);
  return builder_.Finish();
}

inline flatbuffers::Offset<Batch> CreateBatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *alias = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *commands = nullptr) {
  return CreateBatch(
      _fbb,
      alias ? _fbb.CreateString(alias) : 0,
      commands ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*commands) : 0);
}

struct Unbatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALIAS = 4
  };
  const flatbuffers::String *alias() const {
    return GetPointer<const flatbuffers::String *>(VT_ALIAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ALIAS) &&
           verifier.Verify(alias()) &&
           verifier.EndTable();
  }
};

struct UnbatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alias(flatbuffers::Offset<flatbuffers::String> alias) {
    fbb_.AddOffset(Unbatch::VT_ALIAS, alias);
  }
  UnbatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnbatchBuilder &operator=(const UnbatchBuilder &);
  flatbuffers::Offset<Unbatch> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Unbatch>(end);
    fbb_.Required(o, Unbatch::VT_ALIAS);
    return o;
  }
};

inline flatbuffers::Offset<Unbatch> CreateUnbatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> alias = 0) {
  UnbatchBuilder builder_(_fbb);
  builder_.add_alias(alias);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unbatch> CreateUnbatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *alias = nullptr) {
  return CreateUnbatch(
      _fbb,
      alias ? _fbb.CreateString(alias) : 0);
}

struct Contract FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6,
    VT_COMMAND = 8,
    VT_CONTRACTNAME = 10
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  const flatbuffers::String *command() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMAND);
  }
  const flatbuffers::String *contractName() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTRACTNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMAND) &&
           verifier.Verify(command()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CONTRACTNAME) &&
           verifier.Verify(contractName()) &&
           verifier.EndTable();
  }
};

struct ContractBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Contract::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Contract::VT_OBJECT, object);
  }
  void add_command(flatbuffers::Offset<flatbuffers::String> command) {
    fbb_.AddOffset(Contract::VT_COMMAND, command);
  }
  void add_contractName(flatbuffers::Offset<flatbuffers::String> contractName) {
    fbb_.AddOffset(Contract::VT_CONTRACTNAME, contractName);
  }
  ContractBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContractBuilder &operator=(const ContractBuilder &);
  flatbuffers::Offset<Contract> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Contract>(end);
    fbb_.Required(o, Contract::VT_OBJECT);
    fbb_.Required(o, Contract::VT_CONTRACTNAME);
    return o;
  }
};

inline flatbuffers::Offset<Contract> CreateContract(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0,
    flatbuffers::Offset<flatbuffers::String> command = 0,
    flatbuffers::Offset<flatbuffers::String> contractName = 0) {
  ContractBuilder builder_(_fbb);
  builder_.add_contractName(contractName);
  builder_.add_command(command);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Contract> CreateContractDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0,
    const char *command = nullptr,
    const char *contractName = nullptr) {
  return CreateContract(
      _fbb,
      object_type,
      object,
      command ? _fbb.CreateString(command) : 0,
      contractName ? _fbb.CreateString(contractName) : 0);
}

struct TxSignature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEY = 4,
    VT_SIGNATURE = 6
  };
  const flatbuffers::String *publicKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY);
  }
  const flatbuffers::String *signature() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATURE) &&
           verifier.Verify(signature()) &&
           verifier.EndTable();
  }
};

struct TxSignatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) {
    fbb_.AddOffset(TxSignature::VT_PUBLICKEY, publicKey);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) {
    fbb_.AddOffset(TxSignature::VT_SIGNATURE, signature);
  }
  TxSignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TxSignatureBuilder &operator=(const TxSignatureBuilder &);
  flatbuffers::Offset<TxSignature> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<TxSignature>(end);
    fbb_.Required(o, TxSignature::VT_PUBLICKEY);
    fbb_.Required(o, TxSignature::VT_SIGNATURE);
    return o;
  }
};

inline flatbuffers::Offset<TxSignature> CreateTxSignature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0) {
  TxSignatureBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<TxSignature> CreateTxSignatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const char *signature = nullptr) {
  return CreateTxSignature(
      _fbb,
      publicKey ? _fbb.CreateString(publicKey) : 0,
      signature ? _fbb.CreateString(signature) : 0);
}

struct Transaction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SENDER = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8,
    VT_TXSIGNATURES = 10,
    VT_HASH = 12
  };
  const flatbuffers::String *sender() const {
    return GetPointer<const flatbuffers::String *>(VT_SENDER);
  }
  Command command_type() const {
    return static_cast<Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TxSignature>> *txSignatures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TxSignature>> *>(VT_TXSIGNATURES);
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SENDER) &&
           verifier.Verify(sender()) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_TXSIGNATURES) &&
           verifier.Verify(txSignatures()) &&
           verifier.VerifyVectorOfTables(txSignatures()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           verifier.EndTable();
  }
};

struct TransactionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sender(flatbuffers::Offset<flatbuffers::String> sender) {
    fbb_.AddOffset(Transaction::VT_SENDER, sender);
  }
  void add_command_type(Command command_type) {
    fbb_.AddElement<uint8_t>(Transaction::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(Transaction::VT_COMMAND, command);
  }
  void add_txSignatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TxSignature>>> txSignatures) {
    fbb_.AddOffset(Transaction::VT_TXSIGNATURES, txSignatures);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(Transaction::VT_HASH, hash);
  }
  TransactionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionBuilder &operator=(const TransactionBuilder &);
  flatbuffers::Offset<Transaction> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Transaction>(end);
    fbb_.Required(o, Transaction::VT_SENDER);
    fbb_.Required(o, Transaction::VT_COMMAND);
    fbb_.Required(o, Transaction::VT_TXSIGNATURES);
    fbb_.Required(o, Transaction::VT_HASH);
    return o;
  }
};

inline flatbuffers::Offset<Transaction> CreateTransaction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> sender = 0,
    Command command_type = Command_NONE,
    flatbuffers::Offset<void> command = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TxSignature>>> txSignatures = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0) {
  TransactionBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_txSignatures(txSignatures);
  builder_.add_command(command);
  builder_.add_sender(sender);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transaction> CreateTransactionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *sender = nullptr,
    Command command_type = Command_NONE,
    flatbuffers::Offset<void> command = 0,
    const std::vector<flatbuffers::Offset<TxSignature>> *txSignatures = nullptr,
    const char *hash = nullptr) {
  return CreateTransaction(
      _fbb,
      sender ? _fbb.CreateString(sender) : 0,
      command_type,
      command,
      txSignatures ? _fbb.CreateVector<flatbuffers::Offset<TxSignature>>(*txSignatures) : 0,
      hash ? _fbb.CreateString(hash) : 0);
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATUS = 4,
    VT_MESSAGE = 6,
    VT_TRANSACTION = 8,
    VT_OBJECT_TYPE = 10,
    VT_OBJECT = 12
  };
  int32_t status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transaction() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTION);
  }
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TRANSACTION) &&
           verifier.Verify(transaction()) &&
           verifier.VerifyVectorOfTables(transaction()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(int32_t status) {
    fbb_.AddElement<int32_t>(Response::VT_STATUS, status, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response::VT_MESSAGE, message);
  }
  void add_transaction(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction) {
    fbb_.AddOffset(Response::VT_TRANSACTION, transaction);
  }
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Response::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Response::VT_OBJECT, object);
  }
  ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t status = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction = 0,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_transaction(transaction);
  builder_.add_message(message);
  builder_.add_status(status);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t status = 0,
    const char *message = nullptr,
    const std::vector<flatbuffers::Offset<Transaction>> *transaction = nullptr,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  return CreateResponse(
      _fbb,
      status,
      message ? _fbb.CreateString(message) : 0,
      transaction ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transaction) : 0,
      object_type,
      object);
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRANSACTION = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transaction() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_TRANSACTION) &&
           verifier.Verify(transaction()) &&
           verifier.VerifyVectorOfTables(transaction()) &&
           verifier.EndTable();
  }
};

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction) {
    fbb_.AddOffset(Request::VT_TRANSACTION, transaction);
  }
  RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Request>(end);
    fbb_.Required(o, Request::VT_TRANSACTION);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_transaction(transaction);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Transaction>> *transaction = nullptr) {
  return CreateRequest(
      _fbb,
      transaction ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transaction) : 0);
}

struct Query FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_UUID = 6
  };
  QueryType type() const {
    return static_cast<QueryType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           verifier.EndTable();
  }
};

struct QueryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(QueryType type) {
    fbb_.AddElement<int8_t>(Query::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Query::VT_UUID, uuid);
  }
  QueryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QueryBuilder &operator=(const QueryBuilder &);
  flatbuffers::Offset<Query> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Query>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query> CreateQuery(
    flatbuffers::FlatBufferBuilder &_fbb,
    QueryType type = QueryType_TransactionHistory,
    flatbuffers::Offset<flatbuffers::String> uuid = 0) {
  QueryBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query> CreateQueryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    QueryType type = QueryType_TransactionHistory,
    const char *uuid = nullptr) {
  return CreateQuery(
      _fbb,
      type,
      uuid ? _fbb.CreateString(uuid) : 0);
}

struct EventSignature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEY = 4,
    VT_SIGNATURE = 6
  };
  const flatbuffers::String *publicKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY);
  }
  const flatbuffers::String *signature() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATURE) &&
           verifier.Verify(signature()) &&
           verifier.EndTable();
  }
};

struct EventSignatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) {
    fbb_.AddOffset(EventSignature::VT_PUBLICKEY, publicKey);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) {
    fbb_.AddOffset(EventSignature::VT_SIGNATURE, signature);
  }
  EventSignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventSignatureBuilder &operator=(const EventSignatureBuilder &);
  flatbuffers::Offset<EventSignature> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<EventSignature>(end);
    fbb_.Required(o, EventSignature::VT_PUBLICKEY);
    fbb_.Required(o, EventSignature::VT_SIGNATURE);
    return o;
  }
};

inline flatbuffers::Offset<EventSignature> CreateEventSignature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0) {
  EventSignatureBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventSignature> CreateEventSignatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const char *signature = nullptr) {
  return CreateEventSignature(
      _fbb,
      publicKey ? _fbb.CreateString(publicKey) : 0,
      signature ? _fbb.CreateString(signature) : 0);
}

struct ConsensusEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRANSACTION = 4,
    VT_EVENTSIGNATURES = 6,
    VT_STATE = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transaction() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EventSignature>> *eventSignatures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventSignature>> *>(VT_EVENTSIGNATURES);
  }
  State state() const {
    return static_cast<State>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_TRANSACTION) &&
           verifier.Verify(transaction()) &&
           verifier.VerifyVectorOfTables(transaction()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENTSIGNATURES) &&
           verifier.Verify(eventSignatures()) &&
           verifier.VerifyVectorOfTables(eventSignatures()) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct ConsensusEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction) {
    fbb_.AddOffset(ConsensusEvent::VT_TRANSACTION, transaction);
  }
  void add_eventSignatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventSignature>>> eventSignatures) {
    fbb_.AddOffset(ConsensusEvent::VT_EVENTSIGNATURES, eventSignatures);
  }
  void add_state(State state) {
    fbb_.AddElement<int8_t>(ConsensusEvent::VT_STATE, static_cast<int8_t>(state), 0);
  }
  ConsensusEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConsensusEventBuilder &operator=(const ConsensusEventBuilder &);
  flatbuffers::Offset<ConsensusEvent> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<ConsensusEvent>(end);
    fbb_.Required(o, ConsensusEvent::VT_TRANSACTION);
    return o;
  }
};

inline flatbuffers::Offset<ConsensusEvent> CreateConsensusEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventSignature>>> eventSignatures = 0,
    State state = State_Undetermined) {
  ConsensusEventBuilder builder_(_fbb);
  builder_.add_eventSignatures(eventSignatures);
  builder_.add_transaction(transaction);
  builder_.add_state(state);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConsensusEvent> CreateConsensusEventDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Transaction>> *transaction = nullptr,
    const std::vector<flatbuffers::Offset<EventSignature>> *eventSignatures = nullptr,
    State state = State_Undetermined) {
  return CreateConsensusEvent(
      _fbb,
      transaction ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transaction) : 0,
      eventSignatures ? _fbb.CreateVector<flatbuffers::Offset<EventSignature>>(*eventSignatures) : 0,
      state);
}

inline bool VerifyObject(flatbuffers::Verifier &verifier, const void *obj, Object type) {
  switch (type) {
    case Object_NONE: {
      return true;
    }
    case Object_Asset: {
      auto ptr = reinterpret_cast<const Asset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object_Domain: {
      auto ptr = reinterpret_cast<const Domain *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object_Account: {
      auto ptr = reinterpret_cast<const Account *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object_Peer: {
      auto ptr = reinterpret_cast<const Peer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyObjectVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObject(
        verifier,  values->Get(i), types->GetEnum<Object>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_Add: {
      auto ptr = reinterpret_cast<const Add *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Transfer: {
      auto ptr = reinterpret_cast<const Transfer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Update: {
      auto ptr = reinterpret_cast<const Update *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Remove: {
      auto ptr = reinterpret_cast<const Remove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Batch: {
      auto ptr = reinterpret_cast<const Batch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Unbatch: {
      auto ptr = reinterpret_cast<const Unbatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Contract: {
      auto ptr = reinterpret_cast<const Contract *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

inline const iroha::ConsensusEvent *GetConsensusEvent(const void *buf) {
  return flatbuffers::GetRoot<iroha::ConsensusEvent>(buf);
}

inline const char *ConsensusEventIdentifier() {
  return "IROH";
}

inline bool ConsensusEventBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ConsensusEventIdentifier());
}

inline bool VerifyConsensusEventBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<iroha::ConsensusEvent>(ConsensusEventIdentifier());
}

inline const char *ConsensusEventExtension() {
  return "iroha";
}

inline void FinishConsensusEventBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<iroha::ConsensusEvent> root) {
  fbb.Finish(root, ConsensusEventIdentifier());
}

}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_API_IROHA_H_
